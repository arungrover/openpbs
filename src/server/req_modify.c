/*
 * Copyright (C) 1994-2016 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information: 
 * 
 * The PBS Pro software is licensed under the terms of the GNU Affero General 
 * Public License agreement ("AGPL"), except where a separate commercial license 
 * agreement for PBS Pro version 14 or later has been executed in writing with Altair.
 *  
 * Altair’s dual-license business model allows companies, individuals, and 
 * organizations to create proprietary derivative works of PBS Pro and distribute 
 * them - whether embedded or bundled with other software - under a commercial 
 * license agreement.
 * 
 * Use of Altair’s trademarks, including but not limited to "PBS™", 
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's 
 * trademark licensing policies.
 *
 */
/**
 * @file    req_modify.c
 *
 * @brief
 * 		req_modify.c	-	Functions relating to the Modify Job Batch Requests.
 *
 * Included funtions are:
 *	post_modify_req()
 *	req_modifyjob()
 *	find_name_in_svrattrl()
 *	modify_job_attr()
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <sys/types.h>
#include "libpbs.h"
#include <signal.h>
#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server.h"
#include "credential.h"
#include "batch_request.h"
#include "job.h"
#include "reservation.h"
#include "queue.h"
#include "work_task.h"
#include "pbs_error.h"
#include "log.h"
#include "pbs_nodes.h"
#include "svrfunc.h"
#include "hook.h"


/* Global Data Items: */

extern attribute_def	    job_attr_def[];
extern char *msg_jobmod;
extern char *msg_manager;
extern char *msg_mombadmodify;
extern char *msg_defproject;
extern char *msg_max_no_minwt;
extern char *msg_min_gt_maxwt;
extern char *msg_nostf_jobarray;
extern int   comp_resc_gt;
extern int   comp_resc_lt;
extern char *resc_in_err;

static resource_def *pseldef = NULL;
extern int scheduler_sock;
extern int scheduler_jobs_stat;

/**
 * @brief
 * post_modify_req - clean up after sending modify request to MOM
 *
 * @param[in]	pwt	-	work task structure
 */
static void
post_modify_req(struct work_task *pwt)
{
	struct batch_request *preq;

	if (pwt->wt_aux2 != 1) /* not rpp */
		svr_disconnect(pwt->wt_event);  /* close connection to MOM */
	preq = pwt->wt_parm1;
	preq->rq_conn = preq->rq_orgconn;  /* restore socket to client */

	if (preq->rq_reply.brp_code) {
		(void)sprintf(log_buffer, msg_mombadmodify, preq->rq_reply.brp_code);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
			preq->rq_ind.rq_modify.rq_objname, log_buffer);
		req_reject(preq->rq_reply.brp_code, 0, preq);
	} else
		reply_ack(preq);
}




/**
 * @brief
 * 		Service the Modify Job Request from client such as qalter.
 *
 * @par	Functionality:
 *		This request automatically modifies one or more of a job's attributes.
 *	An error is returned to the client if the user does not have permission
 *	to perform the modification, the attribute is read-only, the job is
 *	running and the attribute is only modifiable when the job is not
 *	running, the user attempts to modify a subjob of an array.
 *
 *	If any "move job" hooks are in place, they modify the request before
 *	the Server does anything with the request.
 *
 * @param[in] preq - pointer to batch request from client
 */

void
req_modifyjob(struct batch_request *preq)
{
	int		 add_to_am_list = 0; /* if altered during sched cycle */
	int		 bad = 0;
	int		 i;
	int		 jt;		/* job type */
	int		 newstate;
	int		 newsubstate;
	resource_def	*outsideselect = NULL;
	job		*pjob;
	svrattrl	*plist;
	resource	*presc;
	resource_def	*prsd;
	int		 rc;
	int		 running = 0;
	int		 sendmom = 0;
	char		hook_msg[HOOK_MSG_SIZE];
	int		mod_project = 0;

	switch (process_hooks(preq, hook_msg, sizeof(hook_msg),
			pbs_python_set_interrupt)) {
		case 0:	/* explicit reject */
			reply_text(preq, PBSE_HOOKERROR, hook_msg);
			return;
		case 1:   /* explicit accept */
			if (recreate_request(preq) == -1) { /* error */
				/* we have to reject the request, as 'preq' */
				/* may have been partly modified            */
				strcpy(hook_msg,
					"modifyjob event: rejected request");
				log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_HOOK,
					LOG_ERR, "", hook_msg);
				reply_text(preq, PBSE_HOOKERROR, hook_msg);
				return;
			}
			break;
		case 2:	/* no hook script executed - go ahead and accept event*/
			break;
		default:
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK,
				LOG_INFO, "", "modifyjob event: accept req by default");
	}

	if (pseldef == NULL)  /* do one time to keep handy */
		pseldef = find_resc_def(svr_resc_def, "select", svr_resc_size);

	pjob = chk_job_request(preq->rq_ind.rq_modify.rq_objname, preq, &jt);
	if (pjob == (job *)0)
		return;
	/* Accept modify job requests from scheduler for subjobs.
	 * This is needed because scheduler may try to update 
	 * ATTR_RequestedSpec & ATTR_SchedSelect job attribute.
	 */
	if (((jt == IS_ARRAY_Single) || (jt == IS_ARRAY_Range)) &&
		(preq->rq_conn != scheduler_sock)) {
		req_reject(PBSE_IVALREQ, 0, preq);
		return;
	}

	/* allow scheduler to modify job */
	if (preq->rq_conn != scheduler_sock) {
		/* provisioning job is not allowed to be modified */
		if ((pjob->ji_qs.ji_state == JOB_STATE_RUNNING) &&
			(pjob->ji_qs.ji_substate == JOB_SUBSTATE_PROVISION)) {
			req_reject(PBSE_BADSTATE, 0, preq);
			return;
		}
	}

	/* cannot be in exiting or transit, exiting has already be checked */

	if (pjob->ji_qs.ji_state == JOB_STATE_TRANSIT) {
		req_reject(PBSE_BADSTATE, 0, preq);
		return;
	}

	plist = (svrattrl *)GET_NEXT(preq->rq_ind.rq_modify.rq_attr);
	if (plist == (svrattrl *)0) {	/* nothing to do */
		reply_ack(preq);
		return;
	}

	/*
	 * Special checks must be made:
	 *	if during a scheduling cycle and certain attributes are altered,
	 *	   make a note of the job to prevent it from being run now;
	 *	if job is running, only certain attributes/resources can be
	 *	   altered.
	 */

	if (pjob->ji_qs.ji_state == JOB_STATE_RUNNING) {
		running = 1;
	}
	while (plist) {

		i = find_attr(job_attr_def, plist->al_name, JOB_ATR_LAST);

		/*
		 * Is the attribute being altered one which could change
		 * scheduling (ATR_DFLAG_SCGALT set) and if a scheduling
		 * cycle is in progress, then set flag to add the job to list
		 * of jobs which cannot be run in this cycle.
		 * If the scheduler itself sends a modify job request,
		 * no need to delay the job until next cycle.
		 */
		if ((preq->rq_conn != scheduler_sock) && (scheduler_jobs_stat) && (job_attr_def[i].at_flags & ATR_DFLAG_SCGALT))
			add_to_am_list = 1;

		/* Is the attribute modifiable in RUN state ? */

		if (i < 0) {
			reply_badattr(PBSE_NOATTR, 1, plist, preq);
			return;
		}
		if ((running == 1) &&
			((job_attr_def[i].at_flags & ATR_DFLAG_ALTRUN) == 0)) {

			reply_badattr(PBSE_MODATRRUN, 1, plist, preq);
			return;
		}
		if (i == (int)JOB_ATR_resource) {

			prsd = find_resc_def(svr_resc_def, plist->al_resc,
				svr_resc_size);

			if (prsd == 0) {
				reply_badattr(PBSE_UNKRESC, 1, plist, preq);
				return;
			}

			/* is the specified resource modifiable while */
			/* the job is running                         */

			if (running) {

				if ((prsd->rs_flags & ATR_DFLAG_ALTRUN) == 0) {
					reply_badattr(PBSE_MODATRRUN, 1, plist, preq);
					return;
				}

				sendmom = 1;
			}

			/* should the resource be only in a select spec */

			if (prsd->rs_flags & ATR_DFLAG_CVTSLT && !outsideselect && 
				plist->al_atopl.value && plist->al_atopl.value[0]) {
				/* if "-lresource" is set and has non-NULL value,  
				** remember as potential bad resource 
				** if this appears along "select".  
				*/
				outsideselect = prsd;
			}
		}
		if (strcmp(plist->al_name, ATTR_project) == 0) {
			mod_project = 1;
		} else if ((strcmp(plist->al_name, ATTR_runcount) == 0) &&
			((plist->al_flags & ATR_VFLAG_HOOK) == 0) &&
			(plist->al_value != NULL) &&
			(plist->al_value[0] != '\0') &&
			((preq->rq_perm & (ATR_DFLAG_MGWR | ATR_DFLAG_OPWR)) == 0) &&
		(atol(plist->al_value) < \
		    pjob->ji_wattr[(int)JOB_ATR_runcount].at_val.at_long)) {
			sprintf(log_buffer,
				"regular user %s@%s cannot decrease '%s' attribute value from %ld to %ld",
				preq->rq_user, preq->rq_host, ATTR_runcount,
				pjob->ji_wattr[(int)JOB_ATR_runcount].at_val.at_long,
				atol(plist->al_value));
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_ERR,
				pjob->ji_qs.ji_jobid, log_buffer);
			req_reject(PBSE_PERM, 0, preq);
			return;
		}
		plist = (svrattrl *)GET_NEXT(plist->al_link);
	}

	if (outsideselect) {
		presc = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],
			pseldef);
		if (presc &&
			((presc->rs_value.at_flags & ATR_VFLAG_DEFLT) == 0)) {
			/* select is not a default, so reject qalter */

			resc_in_err = strdup(outsideselect->rs_name);
			req_reject(PBSE_INVALJOBRESC, 0, preq);
			return;
		}

	}

	/* modify the jobs attributes */

	bad = 0;
	plist = (svrattrl *)GET_NEXT(preq->rq_ind.rq_modify.rq_attr);
	rc = modify_job_attr(pjob, plist, preq->rq_perm, &bad);
	if (rc) {
		if (pjob->ji_clterrmsg)
			reply_text(preq, rc, pjob->ji_clterrmsg);
		else
			reply_badattr(rc, bad, plist, preq);
		return;
	}

	/* If certain attributes modified and if in scheduling cycle  */
	/* then add to list of jobs which cannot be run in this cycle */

	if (add_to_am_list)
		am_jobs_add(pjob);	/* see req_runjob() */

	/* check if project attribute was requested to be modified to */
	/* be the default project value */
	if (mod_project && (pjob->ji_wattr[(int)JOB_ATR_project].at_flags & \
							ATR_VFLAG_SET)) {

		if (strcmp(pjob->ji_wattr[(int)JOB_ATR_project].at_val.at_str,
			PBS_DEFAULT_PROJECT) == 0) {
			sprintf(log_buffer, msg_defproject,
				ATTR_project, PBS_DEFAULT_PROJECT);
#ifdef NAS /* localmod 107 */
			log_event(PBSEVENT_DEBUG4, PBS_EVENTCLASS_JOB, LOG_INFO,
				pjob->ji_qs.ji_jobid, log_buffer);
#else
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
				pjob->ji_qs.ji_jobid, log_buffer);
#endif /* localmod 107 */
		}
	}

	if (pjob->ji_wattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_MODIFY) {
		struct resource_def *pminmaxwtdef = NULL;
		resource *presc_minwt = NULL;
		resource *presc_maxwt = NULL;
		presc = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],
			pseldef);
		if (presc && (presc->rs_value.at_flags & ATR_VFLAG_DEFLT)) {
			/* changing Resource_List and select is a default   */
			/* clear "select" so it is rebuilt inset_resc_deflt */
			pseldef->rs_free(&presc->rs_value);
		}
		/* Check if STF job:
		 1. A job array can not be STF.
		 2. max_walltime can not exist without min_waltime.
		 3. min_walltime can not be greater than max_walltime.
		 */
		pminmaxwtdef = find_resc_def(svr_resc_def, MIN_WALLTIME, svr_resc_size);
		if (pminmaxwtdef != NULL)
			presc_minwt = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource], pminmaxwtdef);
		pminmaxwtdef = find_resc_def(svr_resc_def, MAX_WALLTIME, svr_resc_size);
		if (pminmaxwtdef != NULL)
			presc_maxwt = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource], pminmaxwtdef);
		if ((presc_minwt != NULL) || (presc_maxwt != NULL)) {
			int err = PBSE_NONE;
			if (is_job_array(pjob->ji_qs.ji_jobid) == IS_ARRAY_ArrayJob)
				err = PBSE_NOSTF_JOBARRAY;
			if (err == PBSE_NONE && presc_minwt == NULL)
				err = PBSE_MAX_NO_MINWT;
			else if (err == PBSE_NONE && presc_maxwt != NULL
				&& (pminmaxwtdef->rs_comp(&(presc_minwt->rs_value), &(presc_maxwt->rs_value)) > 0))
				err = PBSE_MIN_GT_MAXWT;
			if (err != PBSE_NONE) {
				/* clear "min_walltime" and/or "max_walltime" */
				if (presc_minwt != NULL && (presc_minwt->rs_value.at_flags & ATR_VFLAG_SET))
					pminmaxwtdef->rs_free(&presc_minwt->rs_value);
				if (presc_maxwt != NULL && (presc_maxwt->rs_value.at_flags & ATR_VFLAG_SET))
					pminmaxwtdef->rs_free(&presc_maxwt->rs_value);
				req_reject(err, 0, preq);
				log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB,
					LOG_ERR, "", pbse_to_txt(err));
				return;
			}
		}
		/* Since resource attribute of the job have changed, reset any defaults 
		* resource limit which might have been unset */
		if ((rc = set_resc_deflt((void *)pjob, JOB_OBJECT, NULL)) != 0) {
			req_reject(rc, 0, preq);
			return;
		}
	}

	/* if job is not running, may need to change its state */

	if (pjob->ji_qs.ji_state != JOB_STATE_RUNNING) {
		svr_evaljobstate(pjob, &newstate, &newsubstate, 0);
		(void)svr_setjobstate(pjob, newstate, newsubstate);
	} else {
		(void)job_save(pjob, SAVEJOB_FULL);
	}
	(void)sprintf(log_buffer, msg_manager, msg_jobmod,
		preq->rq_user, preq->rq_host);
	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
		pjob->ji_qs.ji_jobid, log_buffer);

	/* if a resource limit changed for a running job, send to MOM */

	if (sendmom) {
		rc = relay_to_mom(pjob, preq, post_modify_req);
		if (rc)
			req_reject(rc, 0, preq);    /* unable to get to MOM */
		return;
	}

	reply_ack(preq);
}

/**
 * @brief
 * Returns the svrattrl entry matching attribute 'name', or NULL if not found.
 *
 * @param[in]	plist	-	head of svrattrl list
 * @param[in]	name	-	matching attribute 'name'
 *
 * @return	svrattrl entry matching attribute 'name'
 * @retval	NULL	: if entry not found
 */
static svrattrl *
find_name_in_svrattrl(svrattrl *plist, char *name)
{

	if (!name)
		return NULL;

	while (plist) {

		if (strcmp(plist->al_name, name) == 0) {
			return plist;
		}

		plist = (svrattrl *)GET_NEXT(plist->al_link);
	}
	return NULL;
}

/**
 * @brief
 * 		modify_job_attr - modify the attributes of a job automatically
 *	Used by req_modifyjob() to alter the job attributes and by
 *	stat_update() [see req_stat.c] to update with latest from MOM
 *
 * @param[in,out]	pjob	-	job structure
 * @param[in,out]	plist	-	Pointer to list of attributes
 * @param[in]	perm	-	Permissions of the caller requesting the operation
 * @param[out]	bad	-	Pointer to the attribute index in case of a failed
 */
int
modify_job_attr(job *pjob, svrattrl *plist, int perm, int *bad)
{
	int	   changed_resc;
	int	   allow_unkn;
	long	   i;
	int	   modified = 0;
	attribute  newattr[(int)JOB_ATR_LAST];
	attribute *pattr;
	resource  *prc;
	int	   rc;
	int        newstate = -1;
	int        newsubstate = -1;
	long  	   newaccruetype = -1;
	char	  *cumulative_spec = NULL;
	char	  *temp = NULL;
	int       multi_select = 0;
	int       select_modified= 0;

	if (pjob->ji_qhdr->qu_qs.qu_type == QTYPE_Execution)
		allow_unkn = -1;
	else
		allow_unkn = (int)JOB_ATR_UNKN;

	pattr = pjob->ji_wattr;

	/* call attr_atomic_set to decode and set a copy of the attributes */

	rc = attr_atomic_set(plist, pattr, newattr, job_attr_def, JOB_ATR_LAST,
		allow_unkn, perm, bad);

	/* If resource limits are being changed ... */

	changed_resc = newattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_SET;
	if ((rc == 0) && (changed_resc != 0)) {

		/* first, remove ATR_VFLAG_DEFLT from any value which was set */
		/* it can no longer be a "default" as it explicitly changed   */

		prc = (resource *)GET_NEXT(newattr[(int)JOB_ATR_resource].at_val.at_list);
		while (prc) {
			if ((prc->rs_value.at_flags & (ATR_VFLAG_MODIFY|ATR_VFLAG_DEFLT)) == (ATR_VFLAG_MODIFY|ATR_VFLAG_DEFLT))
				prc->rs_value.at_flags &= ~ATR_VFLAG_DEFLT;

			if ((prc->rs_value.at_flags & (ATR_VFLAG_MODIFY|ATR_VFLAG_SET)) == (ATR_VFLAG_MODIFY|ATR_VFLAG_SET)) {
				/* if being changed at all, see if "select" */
				if (prc->rs_defin == pseldef) {
					select_modified = 1;
					if((rc = validate_perm_res_in_select(prc->rs_value.at_val.at_str)) != 0)
						break;
					if (strstr(prc->rs_value.at_val.at_str,"||") != NULL)
					{
						multi_select = 1;
						job_attr_def[(int)JOB_ATR_multiselect].at_decode(&newattr[(int)JOB_ATR_multiselect], NULL, NULL, "true");
						rc = get_most_restrictive_spec(prc->rs_value.at_val.at_str, &cumulative_spec,MAX_RESC_SPEC);
						if (rc)
							break;
						else {
							if (cumulative_spec[0] != '\0') {
								temp = prc->rs_value.at_val.at_str;
								/* cumulative_spec is calculated by get_most_restrictive_spec().  
								 * We temporarily set this into the select so set_chunk_sum() can 
								 * check against the most restrictive limits
								 */
								prc->rs_value.at_val.at_str = cumulative_spec;
								rc = set_chunk_sum(&prc->rs_value, &newattr[(int)JOB_ATR_max_resc_req]);
								prc->rs_value.at_val.at_str = temp;
								if (rc) {
									free(cumulative_spec);
									break;
								}
							}
							free(cumulative_spec);
						}
						rc = get_most_restrictive_spec(prc->rs_value.at_val.at_str, &cumulative_spec,MIN_RESC_SPEC);
						if (rc)
							break;
						else {
							if (cumulative_spec[0] != '\0') {
								temp = prc->rs_value.at_val.at_str;
								/* cumulative_spec is calculated by get_most_restrictive_spec().  
								 * We temporarily set this into the select so set_chunk_sum() can 
								 * check against the most restrictive limits
								 */
								prc->rs_value.at_val.at_str = cumulative_spec;
								rc = set_chunk_sum(&prc->rs_value, &newattr[(int)JOB_ATR_min_resc_req]);
								prc->rs_value.at_val.at_str = temp;
								if (rc) {
									free(cumulative_spec);
									break;
								}
							}
							free(cumulative_spec);
						}
					}
					else {
						/* select is modified, recalc chunk sums */
						rc = set_chunk_sum(&prc->rs_value,
							&newattr[(int)JOB_ATR_resource]);
						if (rc)
							break;
					}

				}
			}
			prc = (resource *)GET_NEXT(prc->rs_link);
		}

		/* Manager/Operator can modify job just about any old way     */
		/* So, the following checks are made only if not the Op/Admin */

		if ((perm & (ATR_DFLAG_MGWR | ATR_DFLAG_OPWR)) == 0) {
			if (pjob->ji_qs.ji_state == JOB_STATE_RUNNING) {

				/* regular user cannot raise the limits of a running job */

				if ((comp_resc(&pjob->ji_wattr[(int)JOB_ATR_resource],
					&newattr[(int)JOB_ATR_resource]) == -1) ||
					comp_resc_lt)
					rc = PBSE_PERM;

			}

			/* Also check against queue, system and entity limits */


			if (rc == 0) {
				comp_resc_gt = comp_resc_lt = 0;
				if ((pjob->ji_qhdr != NULL) && (pjob->ji_wattr[(int)JOB_ATR_multiselect].at_flags & ATR_VFLAG_SET))
				{
					if ((comp_resc(&pjob->ji_qhdr->qu_attr[QA_ATR_ResourceMin], &newattr[(int)JOB_ATR_min_resc_req]) == -1) ||
						comp_resc_gt)
						rc = PBSE_EXCQRESC;
					if (rc == 0) {
						/* now check individual resources against queue or server maximum */
						chk_svr_resc_limit(&newattr[(int)JOB_ATR_max_resc_req], &pjob->ji_qhdr->qu_attr[QA_ATR_ResourceMax],
								    &server.sv_attr[SRV_ATR_ResourceMax], pjob->ji_qhdr->qu_qs.qu_type); 

						if (comp_resc_lt > 0)
							rc = PBSE_EXCQRESC;
					}

				}
				if (rc == 0)
					rc =  chk_resc_limits(&newattr[(int)JOB_ATR_resource],
						pjob->ji_qhdr);
			}
			if (rc == 0) {
				rc = check_entity_resc_limit_max(pjob, pjob->ji_qhdr,
					&newattr[(int)JOB_ATR_resource]);
				if (rc == 0) {
					rc = check_entity_resc_limit_queued(pjob, pjob->ji_qhdr,
						&newattr[(int)JOB_ATR_resource]);
					if (rc == 0) {
						if (multi_select == 1) {
							rc = check_entity_resc_limit_max(pjob, pjob->ji_qhdr,
								&newattr[(int)JOB_ATR_max_resc_req]);
							if (rc == 0)
								rc = check_entity_resc_limit_max(pjob,
									(pbs_queue *)0,
									&newattr[(int)JOB_ATR_max_resc_req]);
						}
						else
						{
							rc = check_entity_resc_limit_max(pjob, (pbs_queue *)0,
								&newattr[(int)JOB_ATR_resource]);
							if (rc == 0)
								rc = check_entity_resc_limit_queued(pjob, (pbs_queue *)0,
									&newattr[(int)JOB_ATR_resource]);
						}
					}
				}
			}
		}
	}

	/* special check on permissions for hold */

	if ((rc == 0) &&
		(newattr[(int)JOB_ATR_hold].at_flags & ATR_VFLAG_MODIFY)) {
		svrattrl *hold_e = find_name_in_svrattrl(plist, ATTR_h);
		/* don't perform permission check if Hold_Types attribute */
		/* was set in a hook script (special privilege) */
		if ((hold_e == NULL) ||
			((hold_e->al_flags & ATR_VFLAG_HOOK) == 0)) {
			i = newattr[(int)JOB_ATR_hold].at_val.at_long ^
				(pattr+(int)JOB_ATR_hold)->at_val.at_long;
			rc = chk_hold_priv(i, perm);
		}
	}

	if (rc == 0) {
		for (i=0; i<JOB_ATR_LAST; i++) {
			if (newattr[i].at_flags & ATR_VFLAG_MODIFY) {
				if ((job_attr_def[i].at_flags & ATR_DFLAG_NOSAVM)==0)
					modified = 1;	/* full save to disk for job */
				if (job_attr_def[i].at_action) {
					rc = job_attr_def[i].at_action(&newattr[i],
						pjob, ATR_ACTION_ALTER);
					if (rc)
						break;
				}
			}
		}
		if ((rc == 0) &&
			((newattr[(int)JOB_ATR_userlst].at_flags & ATR_VFLAG_MODIFY) ||
			(newattr[(int)JOB_ATR_grouplst].at_flags & ATR_VFLAG_MODIFY))) {
			/* Need to reset execution uid and gid */
			rc = set_objexid((void *)pjob, JOB_OBJECT, newattr);
		}

	}
	if (rc) {
		for (i=0; i<JOB_ATR_LAST; i++)
			job_attr_def[i].at_free(newattr+i);
		return (rc);
	}


	/* OK, if resources changed, reset entity sums */

	if (changed_resc) {
		(void)set_entity_resc_sum_max(pjob, (pbs_queue *)0,
			&newattr[(int)JOB_ATR_resource],
			INCR);
		(void)set_entity_resc_sum_queued(pjob, (pbs_queue *)0,
			&newattr[(int)JOB_ATR_resource],
			INCR);
		(void)set_entity_resc_sum_max(pjob, pjob->ji_qhdr,
			&newattr[(int)JOB_ATR_resource],
			INCR);
		(void)set_entity_resc_sum_queued(pjob, pjob->ji_qhdr,
			&newattr[(int)JOB_ATR_resource],
			INCR);
	}
	/* When all limits check passed successfully and resource modified was select
	 * we would want to free our previously calculated min/max_resc_req value provided
	 * those were already set
	 */
	if ((rc == 0) && (select_modified == 1)) {
		if (pjob->ji_wattr[(int)JOB_ATR_multiselect].at_flags & ATR_VFLAG_SET)
			job_attr_def[(int)JOB_ATR_multiselect].at_decode(&pjob->ji_wattr[(int)JOB_ATR_multiselect], NULL, NULL, "false");
		if (pjob->ji_wattr[(int)JOB_ATR_max_resc_req].at_flags & ATR_VFLAG_SET)
			job_attr_def[(int)JOB_ATR_max_resc_req].at_free(&pjob->ji_wattr[(int)JOB_ATR_max_resc_req]);
		if (pjob->ji_wattr[(int)JOB_ATR_min_resc_req].at_flags & ATR_VFLAG_SET)
			job_attr_def[(int)JOB_ATR_min_resc_req].at_free(&pjob->ji_wattr[(int)JOB_ATR_min_resc_req]);
	}

	/* Now copy the new values into the job attribute array */

	for (i=0; i<JOB_ATR_LAST; i++) {
		if (newattr[i].at_flags & ATR_VFLAG_MODIFY) {
			job_attr_def[i].at_free(pattr+i);
			switch (i) {
				case JOB_ATR_state:
					newstate =
						state_char2int(newattr[i].at_val.at_char);
					break;
				case JOB_ATR_substate:
					newsubstate = newattr[i].at_val.at_long;
					break;
				case JOB_ATR_accrue_type:
					newaccruetype = newattr[i].at_val.at_long;
					break;
				default:
					if ((newattr[i].at_type == ATR_TYPE_LIST) ||
						(newattr[i].at_type == ATR_TYPE_RESC)) {
						list_move(&newattr[i].at_val.at_list,
							&(pattr+i)->at_val.at_list);
					} else {
						*(pattr+i) = newattr[i];
					}
			}
			/* ATR_VFLAG_MODCACHE will be included if set */
			(pattr+i)->at_flags = newattr[i].at_flags;
		}
	}
	/* note, the newattr[] attributes are on the stack, they goaway auto */

	if (newstate != -1 && newsubstate != -1) {
		svr_setjobstate(pjob, newstate, newsubstate);
	}

	if (newaccruetype != -1)
		update_eligible_time(newaccruetype, pjob);

	if (modified)
		pjob->ji_modified = 1;	/* an attr was modified, do full save */
	return (0);
}
