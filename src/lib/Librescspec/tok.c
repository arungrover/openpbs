/*
 *  Copyright (C) 2003-2016 Altair Engineering, Inc. All rights reserved.
 *
 *  ALTAIR ENGINEERING INC. Proprietary and Confidential. Contains Trade Secret
 *  Information. Not for use or disclosure outside ALTAIR and its licensed
 *  clients. Information contained herein shall not be decompiled, disassembled,
 *  duplicated or disclosed in whole or in part for any purpose. Usage of the
 *  software is only as explicitly permitted in the end user software license
 *  agreement.
 *
 *  Copyright notice does not imply publication.
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tok.h"

extern char *yytext;
extern int cur_char;

/*
 *
 *	make_token - make a parsetree node
 *		     called by the scanner when it finds a parsable token
 *
 *	returns the token code of the new parse node
 *
 */
int
make_token(int token_code)
{
	cur_char += strlen(yytext);

	if ((yylval = new_rescspec()) == NULL)
		exit(1);

	yylval->char_num = cur_char;

	if (token_code == TOK_STRING) {
		if (yytext[0] == '\\')
			yytext++;
		yytext++;				/* move past the first " or ' */
		if (yytext[strlen(yytext)-2] == '\\')
			yytext[strlen(yytext)-2] = '\0';	/* remove the ending " or ' */
		else
			yytext[strlen(yytext)-1] = '\0';
	}

	yylval->token_code = token_code;
	if ((yylval->lex_info = strdup(yytext)) == NULL) {
		free(yylval);
		exit(1);
	}

	yylval->parent = NULL;
	yylval->left_child = NULL;
	yylval->right_child = NULL;

	return yylval->token_code;
}

/*
 *
 *	new_rescspec - create a new rescspec and initialize it
 *
 *	returns new rescspec
 *
 */
rescspec *
new_rescspec()
{
	rescspec *r;

	if ((r = (rescspec *) malloc(sizeof(rescspec))) == NULL) {
		perror("new_rescspec");
		return NULL;
	}

	r->token_code = 0;
	r->lex_info = NULL;
	r->char_num = 0;
	r->parent = NULL;
	r->left_child = NULL;
	r->right_child = NULL;

	return r;
}

/*
 *
 *	free_rescspec - free a rescspec tree
 *
 *	  root - the spec to free
 *
 *	returns nothing
 *
 */
void
free_rescspec(rescspec *root)
{
	if (root == NULL)
		return;

	free_rescspec(root->left_child);
	free_rescspec(root->right_child);

	if (root->lex_info != NULL)
		free(root->lex_info);
	free(root);
}

/*
 *
 *	dup_rescspec - duplicate a rescspec tree
 *
 *	  rspec - the spec to duplicate
 *
 *	returns a duplicated rescspec tree
 *
 */
rescspec *
dup_rescspec(rescspec *rspec)
{
	rescspec *nrspec;

	if (rspec == NULL)
		return NULL;

	if ((nrspec = new_rescspec()) == NULL)
		return NULL;

	nrspec->token_code = rspec->token_code;
	if ((nrspec->lex_info = strdup(rspec->lex_info)) == NULL) {
		free(nrspec);
		return NULL;
	}

	nrspec->char_num = rspec->char_num;

	nrspec->left_child = dup_rescspec(rspec->left_child);
	nrspec->right_child = dup_rescspec(rspec->right_child);

	if (nrspec->left_child != NULL)
		nrspec->left_child->parent = nrspec;

	if (nrspec->right_child != NULL)
		nrspec->right_child->parent = nrspec;

	return nrspec;
}

/*
 *
 *	translate a token code into a human readable strring
 *
 *	returns the translated string
 *
 */
char *
trans_sym_name(int code)
{
	switch (code) {
		case TOK_INT:
			return "TOK_INT";

		case TOK_FLOAT:
			return "TOK_FLOAT";

		case TOK_SIZE:
			return "TOK_SIZE";

		case TOK_RESC:
			return "TOK_RESC";

		case TOK_STRING:
			return "TOK_STRING";

		case TOK_TIME:
			return "TOK_TIME";

		case TOK_GT:
			return "TOK_GT";

		case TOK_GE:
			return "TOK_GE";

		case TOK_LT:
			return "TOK_LT";

		case TOK_LE:
			return "TOK_LE";

		case TOK_EQ_COMP:
			return "TOK_EQ_COMP";

		case TOK_EQ_ASSN:
			return "TOK_EQ_ASSN";

		case TOK_LP:
			return "TOK_LP";

		case TOK_RP:
			return "TOK_RP";

		case TOK_AND:
			return "TOK_AND";

		case TOK_OR:
			return "TOK_OR";

		default:
			return "";
	}
}

